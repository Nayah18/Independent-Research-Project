"""
==============================================================================
Script Name: modeller_restraints.py

Description: This script performs protein structure alignment, applies distance 
             and angle restraints using trRosetta-derived predictions, and optimizes 
             the model using the Modeller functions and methods.

References:
    - Modeller Manual. Available at: https://salilab.org/modeller/manual/

Functions:
    - Alignment of protein structures using sequence and 3D structure.
    - Application of distance and angle restraints derived from trRosetta.
    - Optimization of the protein model using conjugate gradients.

Requirements:
    - Modeller 10.5 installed
    - NumPy library for numerical operations.
    - PDB files generated by trRosetta and AlphaFold.

Usage:
    Execute the script after loading Modeller and  installing dependencies 
   
==============================================================================
"""

from modeller import *
from modeller.automodel import *
from modeller.optimizers import ConjugateGradients
import numpy as np
import os

# Setting up the Modeller environment
env = Environ()
env.io.atom_files_directory = ['./', '../atom_files/']

# Creating a new empty alignment and model
aln = Alignment(env)
mdl = Model(env)

# List of PDB files to be aligned (trRosetta model produced on trRosetta alongside the restraints AF3 model)
pdb_files = [' trRosetta_model.pdb', 'AF3.pdb']

# Reading and appending each model to the alignment
for code in pdb_files:
    mdl.read(file=code, model_segment=('FIRST:@', 'END:'))
    aln.append_model(mdl, align_codes=code, atom_files=code)

# Aligning them by sequence
aln.malign(gap_penalties_1d=(-500, -300))
aln.write(file='initial-seq.ali')

# Aligning them by structure
aln.malign3d(gap_penalties_3d=(0.0, 2.0))

# Checking the alignment for its suitability for modeling
aln.check()

# Saving the final alignment
alignment_file = 'final.ali'
aln.write(file=alignment_file)

# Using the generated alignment 

log.verbose()
env.io.atom_files_directory = ['.', './atom_files']

# Reading the topology and parameter libraries
env.libs.topology.read(file='$(LIB)/top_heav.lib')
env.libs.parameters.read(file='$(LIB)/par.lib')
print("Topology and parameter libraries read.")

# Reading in the target sequence/alignment
aln = Alignment(env)
aln.append(file=alignment_file, alignment_format='PIR')
print("Alignment loaded. Number of sequences in alignment:", len(aln))

# Generating topology for the target
mdl = Model(env)
mdl.generate_topology(aln[-1])
print("Topology generated. Number of atoms:", len(mdl.atoms))

# Checking atom types after generating topology (due to error)
invalid_atom_count = 0
for atom in mdl.atoms:
    if atom.type == 0:
        print(f"Warning: Atom {atom.index} has an invalid type.")
        invalid_atom_count += 1
print(f"Total number of invalid atom types: {invalid_atom_count}")

# If there are invalid atom types, raise an error and exit (helped debugging)
if invalid_atom_count > 0:
    raise ValueError("Invalid atom types detected. Check the alignment and PDB files.")

# Building the model
mdl.build(initialize_xyz=False, build_method='INTERNAL_COORDINATES')
print("Model built.")

# Reading in coordinates
mdl.read(file='complex_model.pdb')
print("Coordinates read. Number of residues:", len(mdl.residues))

# Saving the initial model for comparison
initial_output_file = 'ModellerOutput/initial_model.pdb'
mdl.write(file=initial_output_file)
print(f"Initial model written to: {initial_output_file}")

# Applying restraints from TrRosetta
dist = np.load('dist.npy')
phi = np.load('phi.npy')
theta = np.load('theta.npy')
omega = np.load('omega.npy')
print("Restraint files loaded.") #Checking they were indeed loaded with this and the print statements below
print(f"dist shape: {dist.shape}")
print(f"phi shape: {phi.shape}")
print(f"theta shape: {theta.shape}")
print(f"omega shape: {omega.shape}")

rsr = mdl.restraints
at = mdl.atoms

# Applying distance restraints
dist_restraint_count = 0
for i in range(dist.shape[0]):
    for j in range(dist.shape[1]):
        d = np.mean(dist[i, j]) if isinstance(dist[i, j], (np.ndarray, list)) else dist[i, j]
        if 0 < d < 0.5 and at[i].type != 0 and at[j].type != 0:  
            try:
                rsr.add(forms.Gaussian(group=physical.xy_distance,
                                       feature=features.Distance(at[i], at[j]),
                                       mean=d, stdev=0.1))
                dist_restraint_count += 1
            except Exception as e:
                print(f"Error applying distance restraint for atoms {i} and {j}: {e}")
        else:
            print(f"Invalid distance {dist[i, j]} at [{i}, {j}] or invalid atom types")
print(f"Distance restraints applied: {dist_restraint_count}")

# Applying angle restraints
angle_restraint_count = 0
for i in range(phi.shape[0]):
    for j in range(phi.shape[1]):
        phi_value = np.mean(phi[i, j]) if isinstance(phi[i, j], (np.ndarray, list)) else phi[i, j]
        theta_value = np.mean(theta[i, j]) if isinstance(theta[i, j], (np.ndarray, list)) else theta[i, j]
        omega_value = np.mean(omega[i, j]) if isinstance(omega[i, j], (np.ndarray, list)) else omega[i, j]

        if phi_value is not None and theta_value is not None and omega_value is not None and \
           at[i].type != 0 and at[j].type != 0 and at[j + 1].type != 0 and at[j + 2].type != 0:
            try:
                rsr.add(forms.Gaussian(group=physical.xy_distance,
                                       feature=features.Angle(at[i], at[j], at[j + 1]),
                                       mean=phi_value, stdev=0.1)) #Kept stdevs like in Modeller manual's example when applying restraints
                rsr.add(forms.Gaussian(group=physical.xy_distance,
                                       feature=features.Angle(at[i], at[j], at[j + 1]),
                                       mean=theta_value, stdev=0.1))
                rsr.add(forms.Gaussian(group=physical.xy_distance,
                                       feature=features.Dihedral(at[i], at[j], at[j + 1], at[j + 2]),
                                       mean=omega_value, stdev=0.1))
                angle_restraint_count += 3
            except Exception as e:
                print(f"Error applying angle restraint for atoms {i}, {j}, {j + 1}, {j + 2}: {e}")
        else:
            print(f"Invalid angle values at [{i}, {j}]: phi={phi[i, j]}, theta={theta[i, j]}, omega={omega[i, j]} or invalid atom types")
print(f"Angle restraints applied: {angle_restraint_count}")

# Minimising the model
mdl.env.schedule_scale = physical.Values(default=1.0)
mdl.restraints.make(mdl, aln=aln, restraint_type='DISTANCE', spline_on_site=False)
mdl.restraints.unpick_all()
mdl.restraints.pick(mdl)
print("Restraints made and picked.")

#Using conjugate gradient for energy minimization
opt = ConjugateGradients()  
try:
    opt.optimize(mdl, max_iterations=1000, min_atom_shift=0.0001)
    print("Model optimized.")
except Exception as e:
    print(f"Error during optimization: {e}") # Was useful when debugging

# Creating output directory if it does not exist
output_dir = 'ModellerOutput'
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# Writing the optimized model with restraints to a file
output_file = os.path.join(output_dir, 'optimized_model_with_restraints.pdb')
mdl.write(file=output_file)
print("Optimized model with restraints has been successfully written to:", output_file)

print(f"Total number of restraints applied: {dist_restraint_count + angle_restraint_count}")
